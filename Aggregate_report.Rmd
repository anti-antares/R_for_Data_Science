

#Data Explore and Clean

```{r warning=FALSE,message=FALSE}
library(tidyverse)
library(caret)
library(ggplot2)
library(randomForest)
library(scales)
library(reshape2)
library(e1071)
library(DataExplorer)
library(corrplot)
library(gridExtra)
library(nnet)
library(factoextra)
library(gbm)

poverty=read_csv("Train.csv")
poverty_test=read_csv("test.csv")
```

```{r}
introduce(poverty)
```

```{r}
introduce(poverty_test)
```

```{r}
table(poverty$Target)
```
```{r}
ggplot(poverty)+geom_bar(aes(Target))+ggtitle("Distribution of Label Feature")+theme(plot.title = element_text(hjust = 0.5))+scale_y_continuous(labels = comma)
```

#Missing Plot
```{r}
poverty_missing=poverty %>%  select(everything()) %>% summarise_all(funs(sum(is.na(.)))) %>% gather(variables,missing_amount) %>% mutate(percent=missing_amount/nrow(poverty)) %>% 
  arrange(percent) %>% mutate(levels=case_when(percent>=0.8~"Remove",
                                              percent>=0.4 & percent<0.8~"Bad",
                                              percent>=0.05 & percent<0.4~"OK",
                                              percent<0.05~"Good")) %>% filter(missing_amount>0)

ggplot(poverty_missing, aes(x = reorder(variables, -percent), y = missing_amount,fill=levels)) + geom_bar(stat = "identity") + coord_flip()+ scale_fill_manual(values=c("#1a9641", "#a6d96a", "#d7191c"))+ xlab("Features") + ylab("Number of missing rows") +   ggtitle("Missing variable plot")+ 
  geom_text(aes(label = paste0(round(100 * percent, 2), "%"))) + scale_y_continuous(labels = comma)+theme(plot.title = element_text(hjust = 0.5))
```

```{r}
a<-ggplot(poverty,aes(x=rooms))+geom_bar()+ylab("Count")+xlab("Number of All Rooms in the House")+scale_y_continuous(labels = comma)

b<-ggplot(poverty,aes(x=tamhog))+geom_bar()+ylab("Count")+xlab("Size of the Household")+scale_y_continuous(labels = comma)

c<-ggplot(poverty,aes(x=escolari))+geom_bar()+ylab("Count")+xlab("Years of Schooling")+scale_y_continuous(labels = comma)

grid.arrange(a,b,c, nrow = 3,top="Distribution Analysis")
```

Let's see among the 142 variables, which variables have the high relations with the degree of poverty (described as the variable called "Target"，the bigger the number, the less of the degree of poverty). For the first step, we can pick some variables to draw precise boxplots and scatterplots and we notice that years of schooling (described as the variable called escolari), and degree of crowding in the house (described as the variable called overcrowding) can have some trends with degree of poverty (some features of these variables change as the degree of poverty goes up). Thus, they should be highly focused when doing the model.
```{r}
p1 <- ggplot(poverty, aes(x = as.factor(Target), y = rooms)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - number of rooms in house") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))

p2 <- ggplot(poverty, aes(x = as.factor(Target), y = hogar_total)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - number of total individual in household") +
  theme(plot.title = element_text(hjust = 0.5, size = 10))

grid.arrange(p1,p2,nrow=2)
```

```{r}
p3 <- ggplot(poverty, aes(x = as.factor(Target), y = SQBdependency)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - dependency squared") +
  theme(plot.title = element_text(hjust = 0.5))

p4 <- ggplot(poverty, aes(x = as.factor(Target), y = escolari)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - year of schooling") +
  theme(plot.title = element_text(hjust = 0.5))

p5 <- ggplot(poverty, aes(x = as.factor(Target), y = overcrowding)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - degree of overcrowding") +
  theme(plot.title = element_text(hjust = 0.5))
grid.arrange(p3,p4,p5,nrow=3)
```

Then we try to use scatterplot to analyze the relationship between variables, we tried a lot and found out that “tamhog (size of the household)” and “tamviv (number of persons living in the household)”, “r4t2 (persons 12 years of age and older)” and “hogar_adul (Number of adults in household)” have a strong positive relationship which can be seen in the following scatterplots. Thus, when doing the model, we should consider relationships between variables such as these ones.
```{r}
p6 <- ggplot(poverty, aes(x = tamhog, y = tamviv,color=as.factor(Target))) +
  geom_point(alpha = 0.3) +
  labs(color="degree_of_poverty")+
  coord_flip()+
  ggtitle("Scatterplot -relationship_tamhog_tamviv") +
  theme(plot.title = element_text(hjust = 0.5))

p7 <- ggplot(poverty, aes(x = hogar_adul, y = r4t2,color=as.factor(Target))) +
  geom_point(alpha = 0.3) +
  labs(color="degree_of_poverty")+
  coord_flip()+
  ggtitle("Scatterplot -relationship_r4t2_hogar_adul") +
  theme(plot.title = element_text(hjust = 0.5))
grid.arrange(p6,p7,nrow=2)
```
#Data Clean
```{r}

feature_list = c(
  "pared",
  "piso",
  "techo",
  "abasta",
  "sanitario",
  "energcocinar",
  "elimbasu",
  "epared",
  "etecho",
  "eviv",
  "estadocivil",
  "parentesco",
  "instlevel",
  "tipovivi",
  "lugar",
  "area"
)


new_features_integer = data.frame(matrix(ncol = length(feature_list), nrow = nrow(poverty)))

ohe_names = vector()

for(i in 1:length(feature_list)){
  
  feature_to_fix = poverty %>% select(starts_with(feature_list[i]))

  
  new_features_integer[,i] = as.integer(factor(names(feature_to_fix)[max.col(feature_to_fix)], ordered = FALSE))
  names(new_features_integer)[i] = paste0(feature_list[i],"_int")
  
  ohe_names = c(ohe_names, as.vector(names(feature_to_fix)))
  
}
for(i in 1:length(feature_list)){
  poverty =poverty %>% select(-starts_with(feature_list[i]))
}

poverty=as_tibble(cbind(poverty , new_features_integer))

new_features_integer = data.frame(matrix(ncol = length(feature_list), nrow = nrow(poverty_test)))

for(i in 1:length(feature_list)){
  

  feature_to_fix = poverty_test %>% select(starts_with(feature_list[i]))
  
 
  new_features_integer[,i] = as.integer(factor(names(feature_to_fix)[max.col(feature_to_fix)], ordered = FALSE))
  names(new_features_integer)[i] = paste0(feature_list[i],"_int")
  
  ohe_names = c(ohe_names, as.vector(names(feature_to_fix)))
  
}
for(i in 1:length(feature_list)){
  poverty_test =poverty_test %>% select(-starts_with(feature_list[i]))
}

poverty_test=as_tibble(cbind(poverty_test , new_features_integer))
```

##Correlation
```{r}
corrma=round(cor(poverty %>% select(-v2a1,-v18q1,-rez_esc,-dependency,-edjefa) %>% na.omit()%>% select_if(is.numeric)),2)

corrplot(corrma,order = "hclust", tl.cex = 0.5)
```

##PCA
```{r warning=FALSE,message=FALSE}

poverty_pca <- read_csv(file = "Train.csv")
poverty_pca_test <-read_csv(file ="test.csv")


poverty_pca$tag <-"Train"
poverty_pca_test$tag <-"Test"

poverty_pca_test $Target <-1
poverty_pca_total <- rbind(poverty_pca,poverty_pca_test)
poverty_pca_total <- poverty_pca_total %>% mutate(Target=as.factor(Target))
poverty_pca_total$v2a1 <-NULL  #NA
poverty_pca_total$v18q1 <-NULL  #NA
poverty_pca_total$rez_esc <-NULL #NA   #33413
#names(which(sapply(poverty_pca_total, anyNA)))
poverty_pca_total$meaneduc <-NULL
poverty_pca_total$SQBmeaned <-NULL

poverty_pca_total$dependency <- NULL
poverty_pca_total$idhogar <-NULL

full = as_tibble(rbind(poverty_pca %>% select,poverty_pca_test))

# Create a list of the features names that need to be reverse engineered

feature_list = c(
  "pared",
  "piso",
  "techo",
  "abasta",
  "sanitario",
  "energcocinar",
  "elimbasu",
  "epared",
  "etecho",
  "eviv",
  "estadocivil",
  "parentesco",
  "instlevel",
  "tipovivi",
  "lugar",
  "area"
)

new_features_integer = data.frame(matrix(ncol = length(feature_list), nrow = nrow(full)))

ohe_names = vector()

for(i in 1:length(feature_list)){
  
  feature_to_fix = full %>% select(starts_with(feature_list[i]))
  
  new_features_integer[,i] = as.integer(factor(names(feature_to_fix)[max.col(feature_to_fix)], ordered = FALSE))
  names(new_features_integer)[i] = paste0(feature_list[i],"_int")
  
  ohe_names = c(ohe_names, as.vector(names(feature_to_fix)))
  
}

poverty_pca_numerical = poverty_pca_total %>% select_if(is.numeric)  ## get the numerical columns 
poverty_pca_numerical$elimbasu5 <- NULL

full_pca = prcomp(poverty_pca_numerical, center = TRUE, scale. = TRUE)
```

```{r}
fviz_eig(full_pca)
```

```{r}


fviz_pca_var(full_pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             select.var = list(contrib = 20), # top 20 contributing
             repel = TRUE     # Avoid text overlapping
             )

poverty_pca_total= poverty_pca_total %>% 
  cbind(full_pca$x[,1:10])
poverty_pca_train <- subset(poverty_pca_total, tag=="Train")
poverty_pca_test <- subset(poverty_pca_total, tag=="Test")
poverty_pca_test$Target <-NULL

```

#Data Preparation
```{r warning=FALSE, message=FALSE}
#randomForest
impute.zero <- function(x) replace(x, is.na(x), 0)
poverty_rf=poverty %>% select(-v2a1,-v18q1,-rez_esc,-Id,-idhogar,-dependency,-edjefa) %>% mutate(SQBmeaned=impute.zero(SQBmeaned),
                                                                                         meaneduc=impute.zero(meaneduc))
poverty_rf$Target=as.factor(poverty_rf$Target)

#GBM
poverty_gbm <- read_csv("Train.csv") %>%
  mutate(Target = as.factor(Target)) %>% 
  select(-dependency,-Id,-idhogar,-v2a1,-v18q1,-rez_esc,-SQBmeaned,-meaneduc)  

poverty_test_gbm <- poverty_test %>%
  select(-dependency,-idhogar,-v2a1,-v18q1,-rez_esc,-SQBmeaned,-meaneduc) 

#Data Split
seed <- 100
set.seed(seed)

inTraining <- createDataPartition(poverty_rf$Target, p=0.7, list=FALSE)
poverty_rf_training=poverty_rf[inTraining,]
poverty_rf_validation=poverty_rf[-inTraining,]

inTraining <- createDataPartition(poverty$Target, p=0.7, list=FALSE)
poverty_gbm_training=poverty_gbm[inTraining,]
poverty_gbm_validation=poverty_gbm[-inTraining,]

inTraining <-createDataPartition(poverty_pca_train$Target,p=0.7,list=FALSE)
poverty_pca_train_training = poverty_pca_train[inTraining,]
poverty_pca_train_validation = poverty_pca_train[-inTraining,]
```


#randomForest
```{r}
impute.zero <- function(x) replace(x, is.na(x), 0)
poverty_rf=poverty %>% select(-v2a1,-v18q1,-rez_esc,-Id,-idhogar,-dependency,-edjefa) %>% mutate(SQBmeaned=impute.zero(SQBmeaned),
                                                                                         meaneduc=impute.zero(meaneduc))
poverty_rf$Target=as.factor(poverty_rf$Target)

seed <- 100
set.seed(seed)

inTraining <- createDataPartition(poverty_rf$Target, p=0.7, list=FALSE)
poverty_rf_training=poverty_rf[inTraining,]
poverty_rf_validation=poverty_rf[-inTraining,]

#control <- trainControl(method="repeatedcv", number=10, repeats=3)
tTrace=trainControl(verboseIter = TRUE)

metric <- "Accuracy"

mtry <- 75
tunegrid <- expand.grid(.mtry=mtry)

#rf_fit3 <- train(Target ~ ., data = poverty_rf_training, method = "rf", metric = "Accuracy", tuneGrid=tunegrid,trControl=tTrace)

#print(rf_fit3)
#save(rf_fit3，file="rf_fit3.rda")



load("rf_fit3.rda")
pred_validation <- predict(rf_fit3, newdata=poverty_rf_validation)
confusionMatrix(data=pred_validation, poverty_rf_validation$Target)

poverty_rf_test=poverty_test%>% select(-v2a1,-v18q1,-rez_esc,-idhogar,-dependency,-edjefa) %>% mutate(SQBmeaned=impute.zero(SQBmeaned),
                                                                                         meaneduc=impute.zero(meaneduc))
pred <- predict(rf_fit3, newdata=poverty_rf_test)
result=data.frame(poverty_rf_test$Id,pred)
colnames(result)=c("Id","Target")
write.csv(result,"rf_submission.csv",row.names=FALSE)
```



```{r}
varImp(rf_fit3)
```


```{r}
impvars <- varImp(rf_fit3)
plot(impvars, main = "Variable Importance for Random Forest")
```



```{r}
p8 <- ggplot(poverty_rf, aes(x = as.factor(Target), y = meaneduc)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - years of education") +
  theme(plot.title = element_text(hjust = 0.5))

p9 <- ggplot(poverty_rf, aes(x = as.factor(Target), y = SQBdependency)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - dependency ratio squared") +
  theme(plot.title = element_text(hjust = 0.5))

p10 <- ggplot(poverty_rf, aes(x = as.factor(Target), y = qmobilephone)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - number of mobile phones") +
  theme(plot.title = element_text(hjust = 0.5))
grid.arrange(p8,p9,p10,nrow=3)
```


#GBM
##Limitations:  
Since we have a limit background knowledge of the mathematical meaning behind the Gbm model, we don’t know much about how to adjust the parameters in the Gbm model. Thus, we didn’t adjust a lot to improve Gbm model, but merely try our best to run it.


##The process of doing the model:  
Since some of the variables have a lot of NA, and from the EDA process we found out that some of them such as v2a1, v18q1, rez_esc, SQBmeaned and meaneduc has too many NAs that we must delete those columns. Also, variables such as edjefa and idhogar also has some NAs and  we know that they are not so important to the degree of poverty based on EDA. Finally, Id has nothing related with the degree of poverty, so we delete all the variables mentioned above when doing Gbm model.


We saved the model as rda file in order to reuse it next time so we comment the code of the model as follow.

```{r}
#poverty_gbm <- expand.grid(interaction.depth = 5,
#                        n.trees = 100,
#                        shrinkage = 0.1,
#                        n.minobsinnode = 10)

#final_Gbm <- train(Target ~., data = poverty_gbm_training, method = "gbm",
#                   tuneGrid = poverty_gbm,
#                   verbose = TRUE)
poverty_gbm_test=read_csv("test.csv")%>%
  select(-dependency,-idhogar,-v2a1,-v18q1,-rez_esc,-SQBmeaned,-meaneduc) 
load("2final_Gbm_.rda")

varImp(final_Gbm)
```
##Findings:
##Variable importance:
From the variable importance plot, we can see that the top three important variables are SQBdependncy, cielorazo, and overcrowding. The above variables mean that dependency, the house quality, the number of children and the degree of overcrowding affect the degree of poverty a lot. Note that when we  did EDA and drew the boxplot, we did find out that overcrowding may be important variable, and the result in Gbm model really shows that we were right.


Also, note that from the boxplots below, we can know that SQBdependncy and overcrowding have the negative relationship with Target. In actual world, it makes sense because when people have more dependencies and are overcrowded when living, they tend to be poor. What’s more, when the quality of house is good, they tend not to be poor.
```{r}
impvars <- varImp(final_Gbm)
plot(impvars, main = "Variable Importance for GBM")

p11 <- ggplot(poverty_gbm_training, aes(x = as.factor(Target), y = overcrowding)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - number of persons per room") +
  theme(plot.title = element_text(hjust = 0.5))

p12 <- ggplot(poverty_gbm_training, aes(x = as.factor(Target), y = SQBdependency)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - dependency ratio squared") +
  theme(plot.title = element_text(hjust = 0.5))

p13 <- ggplot(poverty_gbm_training, aes(x = as.factor(Target), y = cielorazo)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - the area of the ceiling") +
  theme(plot.title = element_text(hjust = 0.5))
grid.arrange(p11,p12,p13,nrow=3)
```

##Confusion matrix:
From the confusion matrix, what we noticed is that the accuracy of Gbm model is 74.55%, not bad. As for the sensitivity, since our goal is to predict the poor people in the country, and the lower the number is, the poorer the people are, so number “1” means the poorest people. And our sensitivity for “1” is meaning 34.51%,  that for the total results we predict, 34.51% we predict is “1” is actually “1”, not very good, but we should notice that in the training set that Kaggle gave us, only 7.9% of the data has the label “1”, and 62.8% of the data has label “4”, so it is normal that the model performs not that good when figuring out people with label “1”.
As for PPV, the PPV for “1” is 71.56%, meaning that for the real world data, 71.56% we predict is “1” is actually “1”.
```{r}
pred_Gbm <- predict(object = final_Gbm, newdata = poverty_gbm_validation, type = "raw")
confusionMatrix(pred_Gbm, poverty_gbm_validation$Target)

poverty_test_id<-poverty_test %>% 
  select(Id)

predTest_Gbm <- predict(object = final_Gbm, newdata = poverty_gbm_test, type = "raw")
result=data.frame(poverty_test_id,predTest_Gbm)
colnames(result)=c("Id","Target")
write.csv(result,"gbm_submission.csv",row.names=FALSE)

```
 

#logistics regression
```{r}
poverty_pca_multinolog <- multinom(Target ~PC1+PC2+PC3+PC4+PC5+PC6+PC7+PC8+PC9+PC10, data=poverty_pca_train_training)
summary(poverty_pca_multinolog)

poverty_pca_log_prediction_train <- predict(object = poverty_pca_multinolog, newdata = poverty_pca_train_training) 
## table(actual = poverty_pca_train$Target, predict = poverty_pca_log_prediction_train)
## confusionMatrix(poverty_pca_log_prediction_train, poverty_pca_train$Target)

poverty_pca_log_prediction_validation <- predict(object = poverty_pca_multinolog, newdata =poverty_pca_train_validation)
confusionMatrix(poverty_pca_log_prediction_validation, poverty_pca_train_validation$Target)

poverty_pca_log_prediction_test <- predict(object = poverty_pca_multinolog, newdata =poverty_pca_test)


result <-data.frame(poverty_pca_test$Id,poverty_pca_log_prediction_test)
colnames(result) <-c("Id","Target")
write.csv(result,"submission_shuting.csv",row.names = FALSE)

```


```{r}
p13 <- ggplot(poverty_pca_train_training, aes(x = as.factor(Target), y = PC1)) +
  geom_boxplot(aes(fill=as.factor(Target))) +
  labs(fill="degree_of_poverty")+
  coord_flip()+
  labs( x="degree of poverty")+
  ggtitle("Frequency distribution - principle component 1") +
  theme(plot.title = element_text(hjust = 0.5))

p13
#grid.arrange(p13,p14,nrow=2)
```

#Conclusion:<br/>
##Which are the most important variables:<br/>
hogar_total, # of total individuals in the household <br/>
r4t3, Total persons in the household <br/>
hhsize, household size<br/>
hogar_nin, Number of children 0 to 19 in household<br/> 
overcrowding  # persons per room<br/>
SQBdependncy, square of dependency-the dependency that should be taken care of in a household<br/>
Cielorazo, the area of the ceiling, indicate the quality of the house<br/>  
Meaneduc，the degree of education<br/> 
Qmobilephone, the quantity of cellphones<br/>


From the boxplots that we previously drew, hogar_total, r4t3, hhsize, hogar_nin, overcrowding  # and  SQBdependncy have the negative relationship with the degree, and Cielorazo, Meaneduc, Qmobilephone have the positive relationship with the degree. Note that if the number of Target goes bigger, it indicates that people are more rich.<br/>


